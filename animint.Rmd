\chapter{Extending ggplot2's grammar of graphics implementation for linked and dynamic graphics on the web}

This chapter is a paper currently under revision with intention of submitting to the Journal of Computational and Graphical Statistics. I am the primary author of the paper and there is a working draft available here -- https://github.com/tdhock/animint-paper/blob/jcgs/HOCKING-animint.pdf

The formatting of paper has been modified to make for consistent typesetting across the thesis.

\specialchapt{ABSTRACT}

The web is the most popular medium for sharing interactive data visualizations thanks to the portability of the web browser and the accessibility of the internet. Unfortunately, creating interactive web graphics often requires a working knowledge of numerous web technologies that are foreign to many people working with data. As a result, web graphics are rarely used for exploratory data analysis where quick iteration between different visualizations is of utmost importance. This is the core strength of ggplot2, a popular data visualization package for R, the world's leading open-source statistical programming language. The conceptual framework behind ggplot2 is based on the grammar of graphics, which lays a foundation for describing any static graphic as a small set of independent components. Perhaps the most fundamental component is the mapping from abstract data to the visual space, sometimes referred to as the aesthetic mapping. We propose adding two new aesthetics to the grammar, which together are sufficient for elegantly describing both animations and certain classes of coordinated linked views. We implement this extension in the open-source R package animint, which converts ggplot2 objects to interactive web visualizations via D3.

\section{Introduction}
\label{sec:intro}

<!--
%% In general, there are three influential roles involving an Animint
%% visualization: the developer, who implements the Animint library; the
%% designer, who uses the Animint library to define a visualization; and
%% the user, who selects data subsets to view in a web browser. The main
%% goal of Animint is to provide an expressive language for designers,
%% while allowing users the freedom to interact with the plot to
%% selectively view data subsets of interest. The designer specifies data
%% sets and maps variables to interactive visual elements using the
%% Animint DSL, then uses the Animint library to compile and save an
%% interactive animation. The user writes no code, but can view and
%% interact with an Animint visualization by clicking Scalable Vector
%% Graphics (SVG) elements in a web browser. The Animint library
%% developer is responsible for the plot rendering details, which allows
%% the others to focus on designing and consuming visualizations.

<<opts, echo=FALSE, message=FALSE, cache=FALSE>>=
knitr::opts_chunk$set(tidy = FALSE, eval = FALSE)
knitr::opts_knit$set(out.format = "latex")
knitr::knit_theme$set("edit-matlab")
@


%%Interactive and dynamic statistical graphics toolkits play an important role in the exploratory phase of a data analysis cycle. The web is an attractive platform for interactive graphics thanks to its portability and accessibility, but due to a lack of tools for quick iteration, web graphics are not a practical tool for exploring data. Instead, they are mostly used for the presentation of findings (i.e., when the 'correct' visualization is already known). This is a source of conflict, as one often needs different tools depending on whether the work is exploratory or intended for public consumption, which results in wasted effort.

%%The R package \texttt{ggplot2} is a popular tool for data visualization due in part to its elegant design inspired by the grammar of graphics. The fundamental concept in the grammar of graphics is that any graphic can be described through a set of mappings from data variables to visual space, referred to commonly as \texttt{aesthetic} mappings. The grammar of graphics and ggplot2 were designed for static graphics
-->

The world's leading open source statistical programming language, R, has a rich
history of interfacing with computational tools for the use of people doing data
analysis and statistics research [@RCore]. Understanding R's core audience 
is important, as they typically want to maximize their time working on data 
analysis problems, and minimize time spent learning computational tools. R 
excels in this regard, as it is designed specifically for interactive use, 
where users can quickly explore their data using highly expressive interfaces.
Another key player in R's success story is its packaging infrastructure, which
provides tools for distributing entire research conpendium(s) (code, data, 
documentation, auxiliary documents, etc) [@Gentleman:Lang]. 

One of the most widely used R packages is ggplot2 [@ggplot2-book], a data
visualization package inspired by the grammar of graphics [@wilkinson]. 
In fact, @Donoho:2015tu writes: ``This effort may have more impact on 
todayâ€™s practice of data analysis than many highly-regarded theoretical 
statistics papers". In our experience, ggplot2 has made an impact thanks to its
foundation in the grammar of graphics, carefully chosen defaults, and overall
usability. This helps data analysts rapidly iterate and discover informative
visualizations -- an essential task in exploratory data analysis (EDA). When 
dealing with high-dimensional data, however, it is often useful to produce 
interactive and/or dynamic graphics, which ggplot2 does not inherently support. 

<!--
%%Since the design space of interactive and dynamic graphics is so large, however, it is extremely difficult to design an fully featured interface that is useful in a EDA setting.
-->

Interactive graphics toolkits in R have been used for decades to enhance the EDA
workflow, but these approaches are often not easy to reproduce or distribute to 
a larger audience. It is true that most graphics generated during EDA are 
ultimately not useful, but sometimes, understanding gained during this phase 
is most easily shared via the interactive graphics themselves. Thus, there is 
value is being able to easily share, and embed interactive graphics inside a 
larger report. Unfortunately, this is typically hard, if not impossible, 
using traditional interactive graphics toolkits. As a result, there is a 
large disconnect between the visualization tools that we use for exploration 
versus presentation. 

We aim to narrow this gap in visualization tools by extending ggplot2's grammar 
of graphics implementation for interactive and dynamic web graphics. Our 
extension allows one to create animated transitions
and perform database queries via direct manipulation of linked views like those
described in [@Ahlberg:1991] and [@Buja:1991vh]. 
A conceptual model for our extension is provided in
Section \ref{sec:extension} and Section \ref{sec:animation}. In 
Section \ref{sec:worldbank}, we demonstrate our extension with an example. 
In Section \ref{sec:implementation}, we outline design decisions made in our
implementation in the R package animint. In Section \ref{sec:performance}, we
provide a sense scope for our system and its performance limitations through a
handful of examples. In Section \ref{sec:compare}, we conduct a comparison
study by replicating examples with other leading systems. Finally, in 
Section \ref{sec:limitations}, we discuss future work and limitations of
our current system.

\section{Related Work}

We aim to provide a system which empowers ggplot2 users to go beyond the 
confines of static graphics with minimal friction imposed upon their current
workflow. We acknowledge that numerous systems which support similar 
visualization techniques exist outside of the R ecosystem, but we 
intentionally focus on R interfaces since the surrounding statistical 
computing environment is crucial for enabling an efficient exploratory data 
analysis workflow.

It is important to acknowledge that ggplot2 is built on top of the R package 
grid, a low-level graphics system, which is now bundled with R itself 
[@RCore]. Neither grid, nor base R graphics, have strong support for 
handling user interaction creating a need for add-on packages. There are a 
number of approaches these packages take to rendering, each with their own 
benefits and drawbacks. Traditionally, they build on low-level R interfaces 
to graphical systems such as GTK+ [@RGtk2], Qt [@qtbase]; [@qtpaint], 
or Java GUI frameworks [@rJava]. In general, the resulting system can be 
very fast and flexible, but sharing ir reproducing output is usually a problem 
due to the heavy software requirements. Although there may be sacrifice in
performance, using the modern web browser as a canvas is more portable, 
accessible, and composable (graphics can be embedded within larger 
frameworks/documents).

Base R does provide a Scalable Vector Graphics (SVG) device, \texttt{svg()}, 
via the Cairo graphics API [@cairo]. The R package SVGAnnotation 
[@SVGAnnotation] provides functionality to post-process \texttt{svg()} 
output in order to add interactive and dynamic features. This is a powerful 
approach, since in theory it can work with any R graphic, but the package is 
self described as a proof-of-concept which reverse engineers poorly structured
\texttt{svg()} output. As a result, anyone wishing to extend or alter the 
core functionality needs a deep understanding of base graphics and SVG. 

The lack of well-structured SVG for R graphics motivated the gridSVG package 
which provides sensible structuring of SVG output for grid graphics 
[@gridSVG]. This package also provides some low-level tools for animating 
or adding interactive features, where grid objects must be referenced by name.
As a result, if one wanted to use this interface to add interactivity to a 
ggplot2 plot, they must know and understand the grid naming scheme ggplot2 uses 
internally and hope it does not change down the road. An interface where 
interactivity can be expressed by referencing the data to be visualized, 
rather than the building blocks of the graphics system, would be preferable 
since the former interface is decoupled from the implementation and does not 
require knowledge of grid.

In terms of the user interface, the R package gganimate is very similar to our
system [@gganimate]. It directly extends ggplot2 by adding a new aesthetic,
named \texttt{frame}, which splits the data into subsets (one for each unique 
value of the frame variable), produces a static plot for each subset, and uses
the animation package to combine the images into a key frame animation 
[@animation]. This is quite similar, but not as flexible as our system's
support for animation, which we fully describe in Section \ref{sec:animation}.
Either system has the ability to control the amount of time that a given frame 
is displayed, but our system can also animate the transition between frames via
the \texttt{d3.transition()} API [@d3]. Smooth transitions help us track
positions between frames, which is useful in many scenarios, such as the 
touring example discussed in Section~6.

Tours are a useful visualization technique for exploring high-dimensional data
which requires interactive and dynamic graphics. The open source software ggobi 
is currently the most fully-featured tool for touring data and has support
for interactive techniques such as linking, zooming, panning, and identifying 
[@ggobi:2007]. The R package rggobi [@rggobi] provides an R interface 
to ggobi's graphical interface, but unfortunately, the software requirements 
for installation and use of this toolchain are heavy and stringent. Furthermore,
sharing the interactive versions of these graphics are not possible. The R 
package cranvas aims to be the successor to ggobi, with support for similar
interactive techniques, but with a more flexible interface for describing 
plots inspired by the grammar of graphics [@cranvas]. Cranvas also has 
heavy and stringent software requirements which limits the portability and
accessibility of the software.

Another R package for interactive graphics which draws design inspiration from 
the grammar of graphics is ggvis [@ggvis]. It does not directly extend 
ggplot2, but instead provides a brand new purely functional interface which 
is designed with interactive graphics in mind. It currently relies on Vega to
render the SVG graphics from JSON [@vega], and the R package shiny to 
enable many of its interactive capabilities [@shiny]. The interface gives
tremendous power to R users, as it allows one to write R functions to handle 
user events. This power does come with a cost, though, as sharing and hosting 
ggvis graphics typically requires special web server software, even when the
interaction logic could be handled entirely client-side. As we outline in 
Section \ref{sec:implementation}, our system does not require a web server, 
but can also be used inside shiny web applications, when desired.

\section{Extending the layered grammar of graphics}

In this section, we propose an extension to the layered grammar of graphics
[@ggplot2-paper] which enables declarative expression of animations and
database queries via direct manipulation. In the ggplot2 system, there are five
essential components that define a layer of graphical markings: data, mappings 
(i.e., aesthetics), geometry, statistic, and position. These simple components 
are easily understood in isolation and can be combined in many ways to express
a wide array of graphics. For a simple example, here is one way to create a
scatterplot in ggplot2 of variables named \texttt{<X>} and \texttt{<Y>} in 
\texttt{<DATA>}:


```r
ggplot() + layer(
  data = <DATA>, 
  mapping = aes(x = <X>, y = <Y>), 
  geom = "point", 
  stat = "identity",
  position = "identity"
)
```

For every geometry, ggplot2 provides a convenient wrapper around 
\texttt{layer()} which provides sensible defaults for the statistic and 
position (in this case, both are "identity"):

```r
ggplot() + geom_point(
  data = <DATA>, 
  aes(x = <X>, y = <Y>)
)
```

A single ggplot2 plot can be comprised of multiple layers, and different layers 
can correspond to different data. Since each graphical mark within a ggplot2 
layer corresponds to one (or more) observations in \texttt{<DATA>}, aesthetic
mappings provide a mechanism for mapping graphical selections to the original 
data (and vice-versa) which is essential to any interactive graphics system
[@viewing-pipeline]; [@plumbing]. Thus, given a way to combine multiple 
ggplot2 plots into a single view, this design can be extended to support a 
notion of multiple linked views, as those discussed in [@Ahlberg:1991] 
and [@Buja:1991vh].

\subsection{Direct Manipulation of Database Queries}
\label{sec:extension}

@ggobi:2007 use SQL queries to formalize the direct manipulation methods
discussed in @Ahlberg:1991 and @Buja:1991vh. As it turns out, we 
can embed this framework inside the layered grammar of graphics with two classes
of new aesthetics: one class to define a selection source and one to define a
target. This is most easily seen using our animint implementation, which has a
\texttt{clickSelects} aesthetic for defining the selection source (via mouse 
click) and a \texttt{showSelected} aesthetic for defining the target. Here we 
use animint to create a linked view between a bar chart and a scatter plot, 
where the user can click on bars to control the points shown in the scatterplot,
as shown in the video in Figure \ref{fig:tips}. As a result, we can quickly see
how the relationship among tip amount and total bill amount depends on whether 
the customer is smoker.

```{r, eval = FALSE}
library(animint)
p1 <- ggplot() + geom_bar(
  data = reshape2::tips, 
  aes(x = smoker, clickSelects = smoker)
)
p2 <- ggplot() + geom_point(
  data = reshape2::tips, 
  aes(x = total_bill, y = tip, 
      showSelected = smoker)
)
animint2dir(list(p1 = p1, p2 = p2))
```

```{r tips, echo = FALSE, fig.cap = "Linked database querying via direct manipulation using animint. A video demonstration can be viewed online at <https://vimeo.com/160496419>"}
knitr::include_graphics("images/tips")
```

In essense, the R code above allows us to use direct manipulation to dynamically
perform SQL queries of the form:

```sql
SELECT total_bill, tip FROM tips
  WHERE smoker IN clickSelects
```

In this example, \texttt{clickSelects} is either "Yes" or "No", but as we show 
in later examples, \texttt{clickSelects} can also be an array of values. 
Although \texttt{clickSelects} is tied to a mouseclick event, this same 
framework supports other selection events, such as hover or click+drag. 
Statistically speaking, this is useful for visualizing and navigating through 
joint distributions conditional upon discrete values. In this sense, our 
extension is closely related to the same a basis which leads to trellis 
displays [@trellis] and linked scatterplot brushing 
[@brushing-scatterplots]. The major differences are that conditioning: 
is layer (i.e., not plot) specific, is not tied to a particular geometry, and 
can be controlled through direct manipulation or animation controls.
%% TODO: make connections to scagnostics? trelliscope?

\subsection{Adding animation}
\label{sec:animation}

In some sense, the \texttt{showSelected} aesthetic splits the layer into subsets
-- one for every unique value of the \texttt{showSelected} variable. The 
\texttt{clickSelects} aesthetics provides a mechanism to alter the visibility 
of those subset(s) via direct manipulation, but our system also provides a 
mechanism for automatically looping through selections to produce animation(s).
We acheive this by reserving the name \texttt{time} to specify which variable 
to select as well as the amount of time to wait before changing the selection 
(in milliseconds). We also reserve the name \texttt{duration} to specify the 
amount of time used to smoothly transition between frames (with linear easing). 
The code below was used to generate Figure \ref{fig:animation} which 
demonstrates a simple animation with smooth transitions between 10 frames of a
single point. Note that the resulting web page has controls for interactively
altering the \texttt{time} and \texttt{duration} parameters. 

```{r, eval = FALSE}
d <- data.frame(v = 1:10)
plotList <- list(
  plot = ggplot() + geom_point(
    data = d, aes(x=v, y=v, showSelected=v)
  ),
  time = list(variable = "v", ms = 1000),
  duration = list(v = 1000)
)
animint2dir(plotList)
```

```{r animation, echo = FALSE, fig.cap = "A simple animation with smooth transitions and interactively altering transition durations. A video demonstration can be viewed online at <https://vimeo.com/160505146>"}
knitr::include_graphics("images/animation")
```


\subsection{World Bank Example}
\label{sec:worldbank}

<!--
%% In the system we propose, the central concept of interactivity is a
%% selection variable, such as year or region in Figure~1. For each
%% selection variable, one or several values can be selected at a time,
%% e.g. year=1979 and country=\{United States, Vietnam\}.  Like
%% Cleveland's system, we also use enhanced linking to highlight the
%% selected value(s) of each selection variable. In contrast to
%% Cleveland's single rectangular brush that selects points in plots of a
%% single data table, we propose several selection variables in linked
%% plots of several data tables. Linking is accomplished using common
%% names when declaring \texttt{clickSelects} and \texttt{showSelected}
%% selection variables.

%% For example, to declare a clickable plot element that changes the
%% selected value of the year variable, a designer writes
%% \texttt{clickSelects=year} (tallrect in Figure~1). And to show only
%% the data subset for the selected value of year, a designer writes
%% \texttt{showSelected=year} (point and text in Figure~1).

%% Using just the \texttt{clickSelects} and \texttt{showSelected}
%% keywords, a wide variety of interactive visualizations can be
%% defined. To make the selection automatically change over time
%% (animation), a designer may declare one variable as the \texttt{time}
%% variable. Since it is perceptually advantageous to have smooth
%% transitions in data-driven animations \citep{animated-transitions}, a
%% designer may also declare a \texttt{duration} list of selection
%% variables which should have smooth transitions.
-->

Figure \ref{fig:worldbank} shows an interactive animation of the World Bank
data set [@WorldBank] created with our animint implementation. The 
visualization helps us explore the change in the relationship between life 
expectancy and fertility over time for 205 countries. By default, the year 
1979 and the countries United States and Vietnam are
selected, but readers are encouraged to watch the video of the animation 
and/or interact the visualization using a web 
browser.\footnote{\url{http://bl.ocks.org/tdhock/raw/8ce47eebb3039263878f/}}
In the interactive version, the selected value of the year variable is
automatically incremented every few seconds, using animation to
visualize yearly changes in the relationship between life expectancy
and fertility rate.

```{r worldbank, echo = FALSE, fig.cap = "An interactive animation of World Bank demographic data of several countries, designed using `clickSelects` and `showSelected` keywords (top).  Left: a multiple time series from 1960 to 2010 of life expectancy, with bold lines showing the selected countries and a vertical grey tallrect showing the selected year. Right: a scatterplot of life expectancy versus fertility rate of all countries. The legend and text elements show the current selection: year=1979, country= {United States, Vietnam}, and region={East Asia & Pacific, North America}"}
knitr::include_graphics("images/figure-1")
```

When viewing the interactive version of Figure \ref{fig:worldbank}, suppose
we wish to select Thailand. Direct manipulation is not very useful in 
this case since it is not easy to identify and select Thailand based
on graphical marks on a plot. For this reason, animint also provides 
dropdown menu(s) for each selection variable to aid the selection process.
Figure \ref{fig:widgets} shows what the user sees after typing ``th'' in 
the search box. Note that these dropdowns support selection of multiple
values and coordinate sensibly with selections made via direct manipulation.

```{r widgets, echo = FALSE, fig.cap = "Animint provides a menu to update each selection variable. In this example, after typing 'th' the country menu shows the subset of matching countries."}
knitr::include_graphics("images/Screenshot-toggle-selected-value")
```

We anticipate that some ggplot2 users will be able to reverse engineer the
animint code which creates Figure \ref{fig:worldbank}, simply by looking at it.
In fact, this is a big reason why ggplot2 is so widely used: 
it helps minimize the amount of time required to translate a figure that exists
in your head into computer code. Note that, in the left hand plot of 
Figure \ref{fig:worldbank}, we have a time series 
of the life expectancy where each line is a country (i.e., we \texttt{group} by
country) and lines are colored by region. By clicking on a line, we also want 
the country label to appear in the right hand plot, so we also need to set 
\texttt{clickSelects=country}. Lastly, by setting \text{showSelected=region},
we can hide/show lines by clicking on the color legend entries.

```{r, eval = FALSE}
timeSeries <- ggplot() + geom_line(
  data = WorldBank,
  aes(x = year, y = life.expectancy,
      group = country, color = region,
      clickSelects = country, 
      showSelected = region)
)
```

We want to provide a visual clue for the selected year in the 
time series, so we also layer some ``tall rectangles" onto the time series.
These tall rectangles will also serve as a way to directly modify the 
selected year. The tallrect geometry is a special case of a rectangle
that automatically spans the entire vertical range, so we just have to 
specify the horizontal range via \texttt{xmin} and \texttt{xmax}. Also, 
since the layered grammar of graphics allows for different data in 
each layer, we supply a data frame with just the unique years in the 
entire data for this layer.

```{r, eval = FALSE}
years <- data.frame(year = unique(WorldBank$year))
timeSeries <- timeSeries + geom_tallrect(
  data = years,
  aes(xmin = year - 0.5, xmax = year + 0.5,
      clickSelects = year)
)
```

As for the right hand plot in Figure \ref{fig:worldbank}, there are 
three layers: a point layer for countries, a text layer for countries, 
and a text layer to display the selected year. By clicking on a point,
we want to display the country text label and highlight the corresponding
time series on the right hand plot, so we set \texttt{clickSelects=country}
in this layer. Furthermore, we only want to show the points for the 
selected year and region, so we also need \texttt{showSelected=year} and 
\texttt{showSelected2=region}.

```{r, eval = FALSE}
scatterPlot <- ggplot() + geom_point(
  data = WorldBank,
  aes(x = fertility.rate, y = life.expectancy,
      color = region, size = population,
      clickSelects = country,
      showSelected = year,
      showSelected2 = region)
)
```

The text layer for annotating selected countries is essentially the same as the
point layer, except we map the country name to the \texttt{label} aesthetic.

```{r, eval = FALSE}
scatterPlot <- scatterPlot + geom_text(
  data = WorldBank,
  aes(x = fertility.rate, y = life.expectancy,
      label = country,
      showSelected = country,
      showSelected2 = year,
      showSelected3 = region)
)
```

Lastly, to help identify the selected year when viewing the scatterplot, 
we add another layer of text at a fixed location.

```{r, eval = FALSE}
scatterPlot <- scatterPlot + geom_text(
  data = years, x = 5, y = 80,
  aes(label = paste("year =", year),
      showSelected = year)
)
```

Now that we have defined the plots in Figure \ref{fig:worldbank}, we can set
the \texttt{time} and \texttt{duration} options (introduced in 
Section \ref{sec:animation}) to control the animation parameters. Our animint
implementation also respects a \texttt{selector.types} option which controls
whether or not selections for a given variable can accumulate and a 
\texttt{first} option for controlling which values are selected by default.
\footnote{We maintain a complete list of (animint specific) options here --
\url{https://github.com/tdhock/animint/wiki/Advanced-features-present-animint-but-not-in-ggplot2}} 
By default, supplying the list of plots and additional options to 
\texttt{animint2dir()} will write all the files necessary to render 
the visualization to a temporary directory and prompt a web browser to 
open an HTML file.

```{r, eval = FALSE}
viz <- list(
  timeSeries = timeSeries,
  scatterPlot = scatterPlot,
  time = list(variable = "year", ms = 3000),
  duration = list(year = 1000),
  selector.types = list(
    year = "single",
    country = "multiple",
    region = "multiple"
  ),
  first = list(
    country = c("United States", "Thailand")
  )
)
animint2dir(viz)
```


\subsection{Implementation details}
\label{sec:implementation}

As shown in Figure \ref{fig:design}, the animint system is implemented
in 2 parts: the compiler and the renderer. The compiler is implemented in about 
2000 lines of R code that converts a list of ggplots and options to a JSON 
plot meta-data file and a tab-separated values (TSV) file database.

<!--
```{r design, echo = FALSE, fig.cap = "A schematic explanation of compilation and rendering in the World Bank visualization. Top: the interactive animation is a list of 4 R objects: 2 ggplots and 2 option lists. Center: animint R code compiles data in ggplot geoms to a database of TSV files (\\textcolor{red}{$\\rightarrowtriangle$}). It also compiles plot meta-data including ggplot aesthetics, animation time options, and transition duration options to a JSON meta-data file ($\\rightarrowtriangle$). Bottom: those data-dependent compiled files are combined with data-independent JavaScript and HTML files which render the interactive animation in a web browser (\\textcolor{blue}{$\\rightarrowtriangle$})."}
knitr::include_graphics("images/figure-design")
```
-->

```{r tornado, echo = FALSE, fig.cap = "Interactive animation of tornadoes recorded from 1950 to 2012 in the United States. Left: map of the lower 48 United States with tornado paths in 1982. The text shows the selected year, and clicking the map changes the selected state, currently Texas. Right: time series of tornado counts in Texas. Clicking a bar changes the selected year, and the text shows selected state and the number of tornadoes recorded there in that year (119 tornadoes in Texas in 1982)."}
knitr::include_graphics("images/figure-tornado")
```

```{r climate, echo = FALSE, fig.cap = "Visualization containing 6 linked, interactive, animated plots of Central American climate data. Top: for the selected time (December 1997), maps displaying the spatial distribution of two temperature variables, and a scatterplot of these two variables. The selected region is displayed with a black outline, and can be changed by clicking a rect on the map or a point on the scatterplot. Bottom: time series of the two temperature variables with the selected region shown in violet, and a scatterplot of all times for that region. The selected time can be changed by clicking a background tallrect on a time series or a point on the scatterplot. The selected region can be changed by clicking a line on a time series."}
knitr::include_graphics("images/figure-climate")
```

The compiler scans the aesthetics in the ggplots to determine
how many selection variables are present, and which geoms to update
after a selection variable is updated. It uses ggplot2 to
automatically calculate the axes scales, legends, labels, backgrounds,
and borders. It outputs this information to the JSON plot meta-data
file.

The compiler also uses ggplot2 to convert data variables (e.g. life
expectancy and region) to visual properties (e.g. y position and
color). The data for each layer/geom are saved in several TSV files,
one for each combination showSelected values. Thus for large data
sets, the web browser only needs to download the subset of data
required to render the current selection [@2013-immens].

When repeated data would be saved in each of the TSV files, an extra
common TSV file is created so that the repeated data only need to be
stored and downloaded once. In that case, the other TSV files do not
store the common data, but are merged with the common data after
downloading. This method for constructing the TSV file database was
developed to minimize the disk usage of animint, particularly
for ggplots of spatial maps as in Figure \ref{fig:tornado}.

Finally, the rendering engine (\texttt{index.html}, \texttt{d3.v3.js},
and \texttt{animint.js} files) is copied to the plot directory. The
\texttt{animint.js} renderer is implemented in about 2200 lines of
JavaScript/D3 code that renders the TSV and JSON data files as SVG in
a web browser. Importantly, animation is achieved by using the
JavaScript \texttt{setInterval} function, which updates the
\texttt{time} selection variable every few seconds. Since the compiled
plot is just a directory of files, the interactive plots can be hosted
on any web server. The interactive plots can be viewed by opening the
\texttt{index.html} page in any modern web browser.

\section{Exploring performance \& scope with examples}
\label{sec:performance}

This section attempts to demonstrate a range of visualizations that 
are supported by animint with more examples. 
Figure \ref{fig:tornado} shows an interactive animation of tornadoes
observed in the United States between 1950 and 2012. At any moment in
time, the user can simultaneously view the spatial distribution of
tornadoes in the selected year over all states, and see the trend over
all years for the selected state. Clicking a state on the map updates the
time series bars to show the tornado counts from that state. Clicking
a bar on the time series updates the selected year. Figure \ref{fig:climate} 
shows an interactive animation of climate
time series data observed in Central America. Two maps display the
spatial distribution of two temperature variables, which are shown
over time in corresponding the time series plots below. Scatterplots
also show the relationships between the two temperature variables for
the selected time and region. Clicking any of the plots updates all 6
of them. The \texttt{clickSelects} and \texttt{showSelected} aesthetics make it
easy to design this set of 6 linked plots in only 87 lines of code.

Summary statistics describing complexity and performance for 
examples in this paper, as well as other animint examples, 
are displayed in Table \ref{tab:examples}. The climate data 
visualization has noticeably slow animations, 
since it displays about 88,980 geometric elements at once 
(\url{http://bit.ly/QcUrhn}). We observed
this slowdown across all browsers, which suggested that there is an
inherent bottleneck when rendering large interactive plots in web
browsers using JavaScript and SVG. Another animint with a similar
amount of total rows is based on the evolution data
(\url{http://bit.ly/O0VTS4}), but since it shows less data onscreen
(about 2703 elements), it exhibits faster responses to interactivity
and animation.

Animint is still useful for creating interactive but
non-animated plots when there is not a time variable in the data.
In fact, 7 of the 11 examples in
Table \ref{tab:examples} are not animated. For example, linked plots
are useful to illustrate complex concepts such as a change point
detection model in the breakpoints data
(\url{http://bit.ly/1gGYFIV}). The user can explore different model
parameters and data sets since these are encoded as animint
interaction variables.

\begin{table*}[htp] % This table is too wide to fill in the page.
  \centering
  \hspace*{-2cm}
  \input{table-examples}
  \vskip 0.2cm
  \caption{Characteristics of 11 interactive visualizations designed with
    animint. The interactive version of these visualizations can be accessed 
    via \url{http://sugiyama-www.cs.titech.ac.jp/~toby/animint/}.
    From left to right, we show the data set name, the
    lines of R code (LOC) including data processing but not including comments
    (80 characters max per line),
    the amount of time it takes to compile the visualization (seconds),
    the total size of the uncompressed TSV files in megabytes (MB),
    the total number of data points (rows),
    the median number of data points shown at once (onscreen),
    the number of data columns visualized (variables),
    the number of \texttt{clickSelects}/\texttt{showSelected} 
    variables (interactive),
    the number of linked panels (plots),
    if the plot is animated,
    and the corresponding Figure number in this paper (Fig).
  }
\label{tab:examples}
\end{table*}

\section{Comparison study}
\label{sec:compare}

In this section we compare our animint implementation with other similar
leading systems by creating a given visualization in each system and
discussing the pros and cons of the different approaches.

\subsection{The Grand Tour}
\label{sec:tour}

The Grand Tour is a well-known method for viewing high dimensional data which
requires interactive and dynamic graphics [@grand-tour]. 
Figure \ref{fig:tour} shows a grand tour of 300 observations sampled
from a correlated tri-variate normal distribution. The left hand view
shows the marginal density of each point while the right hand view ``tours"
through 2D projections of the 3D data. There are many ways to
choose projections in a tour, and many ways to interpolate
between projections, most of which can be programmed fairly easily
using R and relevant add-on packages. In this case, we used the R package tourr,
which uses the geodesic random walk (i.e., random 2D projection with geodesic
interpolation) in its grand tour algorithm [@tourr].

```{r tour, echo = FALSE, fig.cap = "Linked selection in a grand tour with animint. A video demonstration can be viewed online at <https://vimeo.com/160720834>"}
knitr::include_graphics("images/tour")
```

When touring data, it is generally useful to link low-dimensional displays with
the tour itself. The video in Figure \ref{fig:tour} was generated with our
current animint implementation, and points are selected via mouse click which
reveal that points with high marginal density are located in the
ellipsoid center while points with a low marginal density appear near the 
ellipsoid border. In this case, it would be convenient to also have brush 
selection, as we demonstrate in
Figure \ref{fig:tourbrush} which implements the same touring example using the
R packages ggvis and shiny. The brush in Figure \ref{fig:tourbrush} is 
implemented with shiny's support for brushing static images, which currently 
does not support multiple brushes, making it difficult to select
non-contiguous regions. 

```{r tourbrush, echo = FALSE, fig.cap = "Linked selection in a grand tour with ggvis and shiny.  A video demonstration can be viewed online at <https://vimeo.com/160825528>"}
knitr::include_graphics("images/tourbrush")
```

This example helps point out a few other important differences in using 
animint versus ggvis+shiny to implement ``multiple linked and dynamic views" 
as described in [@Ahlberg:1991] and [@Buja:1991vh]. 
Maintaining state of the linked brush in Figure \ref{fig:tourbrush} 
requires both knowledge and clever use of some sophicated programming 
techniques such as closures and reactivity. 
It also requires knowledge of the shiny web application framework and 
a new approach to the grammar of graphics. 
On the other hand, maintaining state in Figure \ref{fig:tour} requires
a few different \texttt{clickSelects}/\texttt{showSelected} mappings. As a
result, we believe animint provides a more elegant user interface for 
this application.

The tourring example also helps point out important consequences of the
design and implementation of these two different systems. As mentioned in 
Section \ref{sec:implementation}, our current animint implementation requires 
every subset of data to be precomputed before render time.
For visualizations such as tours, where it is more efficient to 
perform statistical computations on-the-fly, this can be a harsh restriction, 
but this is a restriction of our current implementation 
(not a restriction of the framework itself).
As a result, when touring a large high-dimensional space, where many 
projections are needed, ggvis+shiny may be desirable since the projections are 
computed on the server and sent to the browser in real-time. This works fine
when the application is running and viewed on the same host machine, but
viewing such an application hosted on a remote machine can produce
staggered animations since client-server requests must be performed, processed,
and rendered roughly 30 times a second. Also, generally speaking, 
the animint system results a more pleasant experience when it comes to hosting 
and sharing applications since it doesn't require a Web Server with R and 
special software already installed.

\subsection{World Bank Example}

We also recreated Figure \ref{fig:worldbank} using ggvis+shiny (see 
\url{http://bit.ly/1SsJKlN}) and Tableau (see 
\url{http://bit.ly/worldBank-tableau}). 
Even as experienced ggvis+shiny users, we found it quite difficult to
replicate this example, and were not able completely replicate it 
due to a lack of a mechanism for coordinating indirect and direct
manipulations. Overall the visualization is pretty similar, but 
lacks a few important features. 
In particular, there is no way to control the selected
year using both the slider (indirect) and clicking on the ggvis plot (direct).
It also lacks the ability to click on a countries time series and label
the corresponding point on the scatterplot. This might be possible, but we
could not find a way to update a plot based on a click event on a different
plot. Even with this lack of functionality, the ggvis+shiny is significantly
more complicated and requires more code 
(about 100 lines of code compared to 30).

<!--
% TODO: redo performance comparison
%We quantified speed differences between the two systems by timing web
%page loading using DevTools in the Chromium web browser Version
%33.0.1750.152, on Ubuntu 12.04 (256984). We also used \texttt{getTime()}
%in JavaScript to record timings for interactive plot updates (on a
%desktop computer with a 2.8GHz Intel Core i7 CPU). Using ggvis with a
%local web server and the World Bank data resulted in a web page that
%loaded quickly (about 1.4s), but updated the plot with a noticeable
%lag after each mouse click (500--1000ms). Note that since we used a
%local web server, these times represent the overhead of the web server
%system, and would be larger with a remote web server.
%
%When we used animint to make the World Bank data visualization, the
%compilation from R objects to 2.1MB of uncompressed TSV data files
%took 2.3s. Using a local web server, the animint JavaScript rendered
%the plot very quickly (100--200ms). We also observed very fast plot
%updates after mouse clicks in animint: 20--30ms response times for
%selecting the year, and 60--70ms response times for selecting the
%country.
%
%The conclusion of our speed comparison is that the overhead of waiting
%for a web server to perform computations results in significant
%slowdowns for interactive animations. It is clear that for quick
%response times, it is preferable to use an entirely JavaScript-based
%system like animint.

%% TDH 20 Nov 2014: When I click on a country on the scatterplot it
%% does not select that country's time series --- is that an inherent
%% limitation of Tableau that we should discuss?
-->

It was also impossible to completely replicate Figure \ref{fig:worldbank}
using Tableau essentially because the example requires a \emph{layered} 
approach to the grammar of graphics. In particular, since graphical
marks and interaction source/target(s) must derive from the same table
in Tableau, it was impossible to control the clickable multiple time 
series and the clickable tallrects in different ways based on the two 
different selection variables. In other words, in Tableau, selections 
are managed on the plot level, but in animint, selections are specific
to each graphical layer.

\section{User feedback and observations}

By working with researchers in several fields of research,
we have created a wide variety of
interactive visualizations using animint.
Typically, the researchers have a complex data set that
they wish to visualize,
but they do not have the expertise or time to create
an interactive data visualization.
The animint system made it easy to collaborate with the various domain experts,
who were able to provide us with annotated sketches of the desired plots,
which we then translated to animint R code.
In this section we share comments and
constructive criticism that we have obtained from our users.

\subsection{User perspective}

For the \texttt{prior} data visualization
(\url{http://bit.ly/1peIT7t}), the animint user is a machine learning
researcher who developed an algorithm and applied it to 4 benchmark
data sets. He wanted to explore how his algorithm performed, in
comparison to a baseline learning algorithm. He appreciated the
intuition about his algorithm's performance that he learned from the
interactive plots: ``Interactive plotting allows us to explore all
relationships of our high-dimensional dataset and gives us an
intuitive understanding of the performance of our proposed
algorithm. An intuitive understanding of the results is important
since it shows under which conditions our proposed method works well
and provides avenues for further research.''

Another user from a machine learning background found the interactive
plots useful for presenting his work: ``the `regularization path' is a
difficult concept to demonstrate in my research. The animint
(\url{http://bit.ly/1gVb8To}) helped greatly by rendering an
interactive plot of regularization path, likelihood, and graph at the
same time and illustrating their connections. It also reveals an
interesting phenomenon that maximizing the testing likelihood actually
gives many false positives.''

In another application, the animint user was a genomics researcher:
``viewing and exploring my complex intestinal microbiome dataset in
animint allowed me to grasp the patterns and relationships between
samples at an almost intuitive level. The interactive aspect of it was
very helpful for browsing through the dataset.''

Finally, users also appreciated the simple web interface, and the
detail that is possible to show in interactive plots, but impossible
to show in publications: ``...  the web interface is simple and easy
to use.  It also enables us to publish more detailed interactive
results on our website to accompany the results presented in
publications.''

\subsection{Developer perspective}

R users, and in particular ggplot2 users, have found that animint 
is easy to learn and use. One statistics Ph.D. student writes, 
``animint is a fantastic framework for creating
interactive graphics for someone familiar with R and ggplot2's grammar
of graphics implementation. The API is very intuitive and allows one
to quickly bring their static graphics to life in a way that
facilitates exploratory data analysis.''

\section{Limitations and future work}
\label{sec:limitations}

<!--
%%The clickSelects/showSelected paradigm is fundamentally a tool for show and hiding subsets of a dataset. For this reason, interactions used to change chart types or select parameters values, turn out to be inefficient, if not impossible.
-->

A number of limitations derive from the fact that some plot features
are computed once during the compilation step and remain static on a
rendered plot. For example, users are unable to change variable
mappings after compilation.
Also, when different data subsets have very different ranges of
values, it may be preferable to recompute scales when
\texttt{clickSelects} selection(s) change. A future
implementation of animint would benefit from changes to the compiler
and renderer that allow scales to be updated after each click. Some 
of these limitations can be resolved by adding interactive widgets
to ``recompile" components hard-coded in the plot meta information.
In fact, animint makes it easy to embed visualizations inside of
shiny web applications, and we have an example of interactively
redefining variable mappings (\url{http://bit.ly/animint-shiny}).

Our compiler also currently takes advantage of ggplot2 internals to compute 
statistics and positional adjustments before rendering. As a result,
statistics/positions will not dynamically recompute based on selections.
In other words, using \texttt{clickSelects}/\texttt{showSelected} with 
non-identity statistic(s)/position(s) may not generate a sensible result. 
It would be possible, but a significant amount of work, to transfer these 
computations from the compiler to the renderer.

Another set of limitations derive our current restriction that all 
subsets (corresponding to each possible selection) must be precomputed
before render time. As eluded to in Section \ref{sec:tour},
if there is a large space of possible selections,
it is impractical to precompute every subset before viewing.
Therefore, it would be useful if the renderer could
dynamically compute subsets when new selections are made. 

Our implementation is also limited to two specific types of
direct manipulation: selecting graphical elements via
mouse click (\texttt{clickSelects}), and showing/hiding related 
elements (\texttt{showSelected}). However, the framework described in 
Section \ref{sec:extension} is not restricted to a particular event type, 
so \texttt{hoverSelects} and \texttt{brushSelects} aesthetics could be 
added, for instance. There are other types of interaction that should be
added, that wouldn't require additional extensions to the grammar of graphics,
such as: zooming, panning, and plot resizing.

\section{Conclusion}

Our R package animint extends ggplot2's layered grammar of graphics 
implementation for a declarative approach to producing interactive
and dynamic web graphics. By adding two aesthetics to specify selection
source(s) and target(s), ggplot2 users can quickly and easily create 
animations with smooth transitions and perform database queries via direct
manipulation of linked views. As a result, animint is a useful tool 
not only for exploratory data analysis, but also for the presentation
and distribution of interactive statistical graphics.

\section*{Acknowledgements}

The authors wish to thank animint users MC Du Plessis, Song Liu,
Nikoleta Juretic, and Eric Audemard
who have contributed constructive criticism and helped its development.
